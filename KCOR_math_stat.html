<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>KCOR (Kirsch Cumulative Outcomes Ratio): Mathematical Form</title>

<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)']],
    displayMath: [['\\[','\\]']],
    packages: {'[+]': ['ams','newcommand','textmacros']}
  },
  loader: {load: ['[tex]/ams','[tex]/newcommand','[tex]/textmacros']}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; margin: 32px; color: #111; }
  h1, h2, h3 { line-height: 1.25; margin-top: 1.6em; }
  code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
  .math-block { margin: 0.8em 0; }
  ul { margin: 0.5em 0 0.5em 1.25em; }
  ol { margin: 0.5em 0 0.5em 1.25em; }
  hr { border: 0; border-top: 1px solid #ddd; margin: 2em 0; }
  .small { color: #444; font-size: 0.95em; }
</style>
</head>
<body>

<h1>KCOR (Kirsch Cumulative Outcomes Ratio): Mathematical Form</h1>

<h2>Setup and notation</h2>
<ul>
  <li>Population indexed by individuals \(i=1,\dots,N\).</li>
  <li>Calendar time is discretized in weeks \(t\in\mathbb{Z}\). Choose an <strong>enrollment</strong> week \(t_0\).</li>
  <li>Define two fixed cohorts at \(t_0\):
    \[
      \mathcal{V}=\{i:\text{vaccinated at }t_0\},\qquad
      \mathcal{U}=\{i:\text{unvaccinated at }t_0\}.
    \]
    (Generalization to more than two cohorts is immediate.)
  </li>
  <li>Let \(Y_i(t)\in\{0,1\}\) be the indicator that individual \(i\) experiences the outcome in week \(t\).</li>
  <li>Weekly outcome counts (e.g., deaths) for cohort \(g\in\{v,u\}\):
    \[
      D_g(t)=\sum_{i\in\mathcal{G}} Y_i(t),\qquad \mathcal{G}\in\{\mathcal{V},\mathcal{U}\}.
    \]
  </li>
  <li>(Optional) At-risk counts \(N_g(t)\) if available. KCOR does <em>not</em> require them.</li>
</ul>

<h2>1) Intrinsic slope estimation (baseline drift)</h2>
<p>Goal: estimate the <strong>cohort-intrinsic</strong> mortality drift due to age/frailty composition, not intervention effect.</p>
<p>Pick a slope model class \(\mathcal{M}\). Common choice: multiplicative (log-linear) trend around \(t_0\):</p>
<div class="math-block">
\[
m_g(t;\theta_g)=\exp(\alpha_g + \beta_g (t-t_0))
\quad \text{or}\quad
m_g(t;\theta_g)=\exp(\alpha_g)\cdot (1+\lambda_g)^{t-t_0}.
\]
</div>
<p>Estimate \(\hat{\theta}_g\) from the observed series \(\{D_g(t)\}_{t\in\mathcal{W}}\) on a <strong>baseline window</strong> \(\mathcal{W}\) chosen to minimize acute exposure effects (e.g., non-COVID period, or trough-to-trough weeks). Options:</p>
<ul>
  <li><em>Two-point estimator</em>: fit \(\beta_g\) (or \(\lambda_g\)) so that \(m_g\) matches \(D_g\) at \(t_0\) and \(t_1\in\mathcal{W}\).</li>
  <li><em>Constrained log-linear regression</em>: minimize \(\sum_{t\in\mathcal{W}} w_t(\log D_g(t)-\log m_g(t;\theta_g))^2\) with a constraint \(m_g(t_0)=D_g(t_0)\).</li>
  <li><em>Smooth-then-fit</em>: LOESS on \(D_g(t)\) to get \(\tilde D_g(t)\), then regress \(\log \tilde D_g(t)\) on \(t\).</li>
</ul>
<p>Define the <strong>neutralizer</strong> (slope removal factor)</p>
<div class="math-block">
\[
n_g(t)=\frac{m_g(t_0;\hat\theta_g)}{m_g(t;\hat\theta_g)}.
\]
</div>
<p>For the log-linear model \(m_g(t)=\exp(\alpha_g+\beta_g(t-t_0))\), this reduces to</p>
<div class="math-block">
\[
n_g(t)=\exp(-\hat\beta_g (t-t_0)).
\]
</div>

<h2>2) Slope-neutralized weekly outcomes</h2>
<p>Apply the neutralizer multiplicatively:</p>
<div class="math-block">
\[
\tilde D_g(t)=D_g(t)\cdot n_g(t),\qquad t\ge t_0.
\]
</div>
<p>This removes cohort-intrinsic drift, leaving (ideally) exposure-related signal plus noise.</p>

<h2>3) Cumulative outcomes</h2>
<p>Compute cumulative (from enrollment):</p>
<div class="math-block">
\[
CD_g(t)=\sum_{\tau=t_0}^{t}\tilde D_g(\tau),\qquad t\ge t_0.
\]
</div>

<h2>4) Raw KCOR curve</h2>
<div class="math-block">
\[
R_{\text{raw}}(t)=\frac{CD_v(t)}{CD_u(t)}.
\]
</div>

<h2>5) Baseline normalization</h2>
<p>Choose a <strong>calibration set</strong> \(\mathcal{B}\subseteq [t_0, t_0+T]\) representing a baseline period (e.g., non-COVID). Pick a constant \(c>0\) such that</p>
<div class="math-block">
\[
\frac{1}{|\mathcal{B}|}\sum_{t\in\mathcal{B}} c\,R_{\text{raw}}(t) = 1.
\]
</div>
<p>Define the <strong>KCOR curve</strong></p>
<div class="math-block">
\[
R(t)=c\,R_{\text{raw}}(t)=c\,\frac{CD_v(t)}{CD_u(t)}.
\]
</div>

<h2>6) Interpretation</h2>
<ul>
  <li>\(R(t)>1\): net harm to the vaccinated cohort up to time \(t\).</li>
  <li>\(R(t)<1\): net benefit to the vaccinated cohort up to time \(t\).</li>
  <li>\(R(t)\) is a <strong>time series</strong>, not a single scalar, and makes <strong>no proportional hazards assumption</strong>.</li>
</ul>


<h2>No proportional hazards assumption — and two kinds of “NPH”</h2>
<p>When we say KCOR “makes no proportional hazards assumption,” we mean it does <strong>not</strong> require the <em>statistical</em> proportional hazards (PH) condition used in Cox models — i.e., the assumption that the hazard ratio between groups is constant over time. KCOR produces a time-evolving ratio \(R(t)\) without forcing it to be flat, so it works even when the hazard ratio changes with time.</p>

<p>However, there’s another phenomenon sometimes also called “non-proportional hazards” that is different: in the COVID context, the relative hazard of death from COVID across age groups is <strong>not proportional</strong> to their baseline (all-cause) mortality hazard. For example, COVID might kill elderly people at 5× their normal ACM hazard but younger people at 50× — so the scaling factor differs by age. This is not about change over time within a group; it’s about the shape of the hazard curve across risk strata.</p>

<p>KCOR sidesteps the <em>first</em> kind of NPH entirely, but the <em>second</em> kind can still distort the result if the intervention cohorts are age-skewed and the disease hazard isn’t proportional to baseline mortality across ages. Slope-neutralization can’t fully correct for that, because it’s not just a slow baseline drift — it’s a structural difference in hazard scaling. The safest way to handle this is to select or stratify cohorts to minimize that skew.</p>

<h2>Self-check property of KCOR</h2>

<p>
One of the strongest features of KCORv3 is that it is <em>self-checking</em>.
If the slope neutralization has been done correctly, the net harm/benefit curve
\[
R(t) = \frac{\mathrm{CD}_v(t)}{\mathrm{CD}_u(t)}
\]
will approach a constant value once the intervention’s short-term effects have worn off and only background mortality remains.
</p>

<p>
Formally, let \( T \) denote the time after which post-intervention hazards are no longer different from baseline hazards.  
For \( t \ge T \),
\[
R(t) \approx \text{constant}.
\]
This constant reflects the residual ratio of cumulative deaths if the cohorts have been properly normalized for intrinsic slope differences.
</p>

<p>
Recall that cumulative deaths are computed as:
\[
\mathrm{CD}_g(t) = \sum_{\tau = 0}^{t} \hat{D}_g(\tau),
\]
where \( \hat{D}_g(\tau) \) is the slope-neutralized deaths per week for group \( g \in \{v, u\} \).
If slope removal is correct, then:
\[
\frac{\mathrm{CD}_v(t)}{\mathrm{CD}_u(t)} \to \text{constant}, \quad t \to \infty.
\]
</p>

<h3>Practical reading</h3>
<ul>
<li>If \( R(t) \) levels off above 1, the intervention produced a net harm signal persisting through \( T \).</li>
<li>If \( R(t) \) levels off below 1, the intervention produced a net benefit signal persisting through \( T \).</li>
<li>If \( R(t) \) oscillates or drifts after \( T \), slope neutralization may be incorrect or residual differences remain between cohorts.</li>
</ul>

<h3>Diagnostics</h3>
<ul>
<li><strong>Flat after \( T \)</strong>: Suggests slope estimation was correct and cohorts are balanced with respect to age/frailty drift.</li>
<li><strong>Upward drift after \( T \)</strong>: Indicates under-correction of the vaccinated slope (harm looks smaller) or over-correction of the unvaccinated slope (benefit looks larger).</li>
<li><strong>Downward drift after \( T \)</strong>: Indicates over-correction of the vaccinated slope or under-correction of the unvaccinated slope.</li>
<li><strong>Non-flat, irregular</strong>: Possible seasonality, residual confounding, or data quality issues.</li>
</ul>

<p>
This self-check property is a built-in validity test:  
if the neutralization is wrong, the curve cannot asymptote to a constant — it will drift or oscillate,  
signaling a methodological error or unadjusted bias.
</p>

<h2>Why KCOR’s self-check is unique</h2>
<p>
Most standard epidemiological estimators (e.g., Cox PH, Poisson/logistic regression, Kaplan–Meier) provide results under modeling
assumptions and only offer <em>optional</em> goodness-of-fit diagnostics. They do not contain a built-in, visual “pass/fail” criterion
tied to their own preprocessing steps. KCOR differs in three ways:
</p>
<ul>
  <li><strong>Intrinsic validation:</strong> After slope neutralization, the KCOR curve \(R(t)=\mathrm{CD}_v(t)/\mathrm{CD}_u(t)\) must asymptote
      to a horizontal line once post-intervention effects dissipate. Persistent drift is a direct signal of mis-specified slope or residual bias.</li>
  <li><strong>No auxiliary tests required:</strong> The validation is part of the method, not an add-on (no residual tests or separate GOF procedures needed).</li>
  <li><strong>Minimal-data robustness:</strong> KCOR’s self-check still functions when only dates (DoI, DoO, optional DoB) or weekly cohort counts are available;
      if normalization is wrong, \(R(t)\) will not flatten.</li>
</ul>
<p>
In short, KCOR’s asymptotic flatness acts as a <em>necessary condition</em> for correct normalization. Standard tools produce estimates even when their
assumptions are violated; KCOR visibly “fails” (non-flat \(R(t)\)) when its key assumption is violated—making errors easy to detect.
</p>


</body>
</html>
